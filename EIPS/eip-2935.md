---
eip: 2935
title: Save and serve limited historical block hashes from state
description: Store and serve previous 8192 block hashes as storage slots of a system contract to allow for stateless execution
author: Vitalik Buterin (@vbuterin), Tomasz Stanczak (@tkstanczak), Guillaume Ballet (@gballet), Gajinder Singh (@g11tech), Tanishq Jasoria (@tanishqjasoria)
discussions-to: https://ethereum-magicians.org/t/eip-2935-save-historical-block-hashes-in-state/4565
status: Draft
type: Standards Track
category: Core
created: 2020-09-03
---

## Abstract

Store last `8192` historical block hashes in a contract, and modify the `BLOCKHASH (0x40)` opcode to read and serve from this contract storage.

## Motivation

Currently `BLOCKHASH` opcode accesses history to resolve hash of the block number in EVM. However a more stateless client friendly way is to maintain and serve these hashes from state.

Although this is possible even in Merkle trie state, but Verkle trie state further allows bundling the `BLOCKHASH` witnesses (along with other witnesses) in an efficient manner making it worthwhile to have these in state.

A side benefit of this approach could be that it allows building/validating proofs related to last `8192` ancestors directly against the current state.

## Specification

| Parameter | Value |
| - | - |
| `FORK_TIMESTAMP` | TBD |
| `HISTORY_STORAGE_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe`|
| `HISTORY_SERVE_WINDOW` | `8192` |
| `BLOCKHASH_PERSIST_WINDOW` | `256` |

This EIP specifies for storing last `HISTORY_SERVE_WINDOW` block hashes in a ring buffer storage of `HISTORY_SERVE_WINDOW` length.


At the start of processing any block where `block.timestamp >= FORK_TIMESTAMP` (ie. before processing any transactions), update the history in the following way:

```python
def process_block_hash_history(block: Block, state: State):
    if block.timestamp >= FORK_TIMESTAMP:
        state.insert_slot(HISTORY_STORAGE_ADDRESS, (block.number-1) % HISTORY_SERVE_WINDOW , block.parent.hash)

    # If this is the fork block, add the parent's direct `BLOCKHASH_PERSIST_WINDOW - 1` ancestors as well
    if block.parent.timestamp < FORK_TIMESTAMP:
        ancestor = block.parent
        for i in range(FORK_TRANSITION_PERSIST_LENGTH - 1):
            # stop at genesis block
            if ancestor.number == 0:
                break

            ancestor = ancestor.parent
            state.insert_slot(HISTORY_STORAGE_ADDRESS, ancestor.number % HISTORY_SERVE_WINDOW, ancestor.hash)
```

Note that if this is the fork block, then it persists the additional requisite history that could be needed while resolving `BLOCKHASH` opcode for all of the `BLOCKHASH_PERSIST_WINDOW` ancestors (up until genesis).

For resolving the `BLOCKHASH` opcode this fork onwards (`block.timestamp >= FORK_TIMESTAMP`), switch the logic to:

```python
def resolve_blockhash(block: Block, state: State, arg: uint64):
  # check the wrap around range
  if arg >= block.number or arg < max(block.number - HISTORY_SERVE_WINDOW, 0)
    return 0

  return state.load_slot(HISTORY_STORAGE_ADDRESS, arg % HISTORY_SERVE_WINDOW)
```

Some activation scenarios:

 * For the fork to be activated at genesis, no history is written to the genesis state, and at the start of block `1`, genesis hash will be written as a normal operation to slot `0`.
 * for activation at block `1`, only genesis hash will be written at slot `0` as there is no additional history that needs to be persisted.
 * for activation at block `32`, block `31`'s hash will be written to slot `31` and additonal history for `0..30`'s hashes will be persisted, so all in all `0..31`'s hashes.
 * for activation at block `1000`, block `744-999`'s hashes will be presisted in the slot and `BLOCKHASH` for `743` or less would resolve to `0` as only `BLOCKHASH_PERSIST_WINDOW` are persisted.

### [EIP-158](./eip-158.md) handling

This address is currently exempt from [EIP-158](./eip-158.md) cleanup in Kaustinen Verkle Testnet but we plan to address this in the following way:

* Deploy a contract Ã  la [EIP-4788](./eip-4788.md) which just supports `get` method to resolve the BLOCKHASH as per the logic defined in `resolve_blockhash` (and use the generated address as the BLOCKHASH contract address).
* While the clients are expected to directly read from state (or maintain and serve from memory) to resolve BLOCKHASH opcode, this contract's `get` could be invoked by transaction (via another contract or directly) leading to a normal contract execution (and gas consumption) as per the semantics of the contract call.


### Gas costs and witnesses

Since now `BLOCKHASH` is served from state, the clients now **additionally** charge the corresponding warm or cold `SLOAD` costs. For verkle based networks this would imply doing and bundling similar accesses (and gas charges) to `SLOAD`.

## Rationale

Very similar ideas were proposed before in [EIP-210](./eip-210.md) et al. This EIP is a simplification, removing two sources of needless complexity:

1. Having a tree-like structure with multiple layers as opposed to a single list
2. Writing the EIP in EVM code
3. Serial unbounded storage of hashes for a deep access to the history

However after weighing pros and cons, we decided to go with just a limited ring buffer to only serve the requisite `HISTORY_SERVE_WINDOW` as [EIP-4788](./eip-4788.md) and beacon state accumulators allow (albeit a bit more complex) proof against any ancestor since merge.

Second concern was how to best transition the BLOCKHASH resolution logic post fork by:

1. Either waiting for  `BLOCKHASH_PERSIST_WINDOW` blocks for the entire relevant history to persist
2. Storing of all last `BLOCKHASH_PERSIST_WINDOW` block hashes on the fork block.

We choose to go with later as it alleviates the need to detect fork activation height to transition to the new logic in backward compatible manner as the entire `BLOCKHASH` requisite history will be available from the first block of the fork itself.
The cost of doing so is marginal considering the `BLOCKHASH_PERSIST_WINDOW` being small and clients should already have it handy for resolving upto `BLOCKHASH_PERSIST_WINDOW` depth.

## Backwards Compatibility

The behavior of `BLOCKHASH` opcode gets extended in backward compatible manner as the history it can serve will get extended with each block post the fork upto `HISTORY_SERVE_WINDOW`. However the gas charges will get bumped as per the additional `SLOAD` costs.

## Test Cases

TBD

## Reference Implementation

 * PR 28878 of go-ethereum
 * Active on verkle-gen-devnet-5 for its verkle implementation

## Security Considerations

Having contracts (system or otherwise) with hot update paths (branches) poses a risk of "branch" poisioning attacks where attacker could sprinkle trivial amounts of eth around these hot paths (branches). But it has been deemed that cost of attack would escalate significantly to cause any meaningful slow down of state root updates.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
