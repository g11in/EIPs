---
eip: 2935
title: Save historical block hashes in state
author: Vitalik Buterin (@vbuterin), Tomasz Stanczak (@tkstanczak), Guillaume Ballet (@gballet), Gajinder Singh (@g11tech), Tanishq Jasoria (@tanishqjasoria)
description: store previous block hashes as storage slots of a system contract to allow for stateless execution
discussions-to: https://ethereum-magicians.org/t/eip-2935-save-historical-block-hashes-in-state/4565
status: Draft
type: Standards Track
category: Core
created: 2020-09-03
---

## Simple Summary

Store historical block hashes in a contract, and modify the `BLOCKHASH (0x40)` opcode to read this contract.

## Motivation

There is increasingly a desire to remove the need for most clients to store history older than some relatively short duration (often between 1 week and 1 year) to save disk space. This requires some form of layer-2 network to help clients access historical information. These protocols can be made much simpler if blocks contained a quick Merkle path to historical blocks.

Additional secondary motivations include:

* The protocol can be used to make more secure efficient light clients with flyclient-like technology (while the "optimal" flyclient protocol is fairly complex, large security gains over the status quo (trusted "canonical hash trees") can be made cheaply)
* Improving cleanness of the protocol, as the BLOCKHASH opcode would then access state and not history.

## Specification

| Parameter | Value |
| - | - |
| `FORK_TIMESTAMP` | TBD |
| `HISTORY_STORAGE_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe`|
| `HISTORY_SERVE_WINDOW` | `256` |

At the start of processing any block where `block.timestamp > FORK_TIMESTAMP` (ie. before processing any transactions), 
* run `sstore(HISTORY_STORAGE_ADDRESS, block.number - 1, block.prevhash)`. 
* **additionally** if this is the first block of the fork, then store last `min(HISTORY_SERVE_WINDOW-1, block.number-1)` **blocks' prevhash** into their corresponding slots i.e persist the entire `HISTORY_SERVE_WINDOW` block hashes (up until the genesis) that can be accessed in the block.
* change the logic of the `BLOCKHASH` opcode as follows: return `sload(HISTORY_STORAGE_ADDRESS, arg)`.

Edge cases:
* For verkle at genesis, no history is written to the genesis state, and at the start of block `1`, genesis hash will be written as a normal operation to slot `0`.
* for verkle activated at block `1`, only genesis hash will be written at slot `0` as no additional history needs to be persisted.
* for verkle activated at block `32`, block `31`'s hash will be written to slot `31` and additonal history for `0..30`'s hashes will be persisted, so all in all `0..31`'s hashes.

## Rationale

Very similar ideas were proposed before in EIP-98 and EIP-210. This EIP is a simplification, removing two sources of needless complexity:

1. Having a tree-like structure with multiple layers as opposed to a single list
2. Writing the EIP in EVM code

The former was intended to save space. Since then, however, storage usage has increased massively, to the point where even eg. 5 million new storage slots are fairly negligible compared to existing usage. The latter was intended as a first step toward "writing the Ethereum protocol in EVM" as much as possible, but this goal has since been de-facto abandoned.

Storing of all last `HISTORY_SERVE_WINDOW` block hashes alleviates the need to detect fork activation height to transition to the new logic as the entire required history will be available from the first block of the fork itself. The cost of doing so is marginal considering the `HISTORY_SERVE_WINDOW` being small.

## Backwards Compatibility

The range of `BLOCKHASH` is increased by this opcode, but behavior within the previous 256-block range remains unchanged.

## Test Cases

TBD

## Implementation

 * PR 28878 of go-ethereum
 * Active on verkle-gen-devet-3 for its verkle implementation

## Security Considerations

Adding ~2.5 million storage slots per year bloats the state somewhat (but not much relative to the hundreds of millions of existing state objects). However, this EIP is not intended to be permanent; when eth1 is merged into eth2, the BLOCKHASH opcode would likely be repurposed to use eth2's built-in history accumulator structure (see [phase 0 spec](https://github.com/ethereum/annotated-spec/blob/master/phase0/beacon-chain.md#slots_per_historical_root)).

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
